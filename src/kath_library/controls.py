import numpy as np
from cogent3.app import evo, io
from cogent3.app.composable import (
    ALIGNED_TYPE,
    BOOTSTRAP_RESULT_TYPE,
    RAISE,
    RESULT_TYPE,
    SERIALISABLE_TYPE,
    ComposableHypothesis,
    NotCompleted,
    user_function,
)
from cogent3.app.result import bootstrap_result, generic_result
from cogent3.util import parallel
from cogent3.util.deserialise import deserialise_object

from kath_library.eop import adjacent_EOP
from kath_library.model import GN_sm, GS_sm
from kath_library.stationary_pi import OscillatingPiException
from kath_library.utils.utils import get_foreground


class expected_dist_stat(ComposableHypothesis):
    """
    bstrap_result
        a specifically constructed generic_result type generated by kath_library.bootstrap.bootstrap

    returns
        a given statistic under the null hypothesis (a GNS process), and under the alternate process (a GN process)
    """

    _input_types = SERIALISABLE_TYPE
    _output_types = SERIALISABLE_TYPE
    _data_types = "generic_result"

    def __init__(self, stat_func, fg_edge, parallel=False, verbose=False):
        super(expected_distributions, self).__init__(
            input_types=self._input_types,
            output_types=self._output_types,
            data_types=self._data_types,
        )
        self.stat_func = stat_func
        self.fg_edge = fg_edge
        self._verbose = verbose
        self._parallel = parallel
        self.func = self.run

    def fit_null(self):
        sim_aln = self.null_params.lf.simulate_alignment()
        sim_aln.info.source = "%s - simalign - null" % (self._inpath)
        sim_aln.info.fg_edge = self.fg_edge

        try:
            sim_model_fit = self.alt(sim_aln)
            sim_result = self.stat_func(sim_model_fit)
        except OscillatingPiException as err:
            sim_result = NotCompleted(
                "ERROR - OscillatingPiException", str(self.stat_func), err.args[0]
            )
        return sim_result, sim_model_fit

    def fit_alt(self):
        sim_aln = self.alt_params.lf.simulate_alignment()
        sim_aln.info.source = "%s - simalign - alt" % (self._inpath)
        sim_aln.info.fg_edge = self.fg_edge

        try:
            sim_model_fit = self.alt(sim_aln)
            sim_result = self.stat_func(sim_model_fit)
        except OscillatingPiException as err:
            sim_result = NotCompleted(
                "ERROR - OscillatingPiException", str(self.stat_func), err.args[0]
            )
        return sim_result, sim_model_fit

    def run(self, bstrap_result):
        result = generic_result(bstrap_result.source)
        self._inpath = bstrap_result.source

        taxa = bstrap_result["observed"].null.alignment.names
        self.alt = GN_sm(list({self.fg_edge} ^ set(taxa)))

        self.null_params = bstrap_result["observed"].null
        self.alt_params = bstrap_result["observed"].alt

        null_result, null_model_fit = self.fit_null()
        alt_result, alt_model_fit = self.fit_alt()

        result["null"] = null_result
        result["null-model_fit"] = null_model_fit

        result["alt"] = alt_result
        result["alt-model_fit"] = alt_model_fit

        return result


class expected_dist_hyp(ComposableHypothesis):
    """
    Parametric bootstrap for a provided hypothesis for 2 alignments simulated under the null and alternate model.
    Only returns the LR for bootstrapped results (to avoid overloading memory for use on nci)
    Returns a generic_result
    """

    _input_types = (ALIGNED_TYPE, SERIALISABLE_TYPE)
    _output_types = (RESULT_TYPE, BOOTSTRAP_RESULT_TYPE, SERIALISABLE_TYPE)
    _data_types = ("ArrayAlignment", "Alignment")

    def __init__(self, hyp, num_reps, parallel=False, verbose=False):
        super(expected_dist_hyp, self).__init__(
            input_types=self._input_types,
            output_types=self._output_types,
            data_types=self._data_types,
        )
        self._formatted_params()
        self._hyp = hyp
        self._num_reps = num_reps
        self._verbose = verbose
        self._parallel = parallel
        self.func = self.run

    def _fit_null_sim(self, rep_num):
        sim_aln = self._null_null.simulate_alignment()
        sim_aln.info.source = "%s - null - simalign %d" % (self._inpath, rep_num)

        try:
            sim_result = self._hyp(sim_aln).LR
        except ValueError:
            sim_result = None
        return sim_result

    def _fit_alt_sim(self, rep_num):
        sim_aln = self._alt_null.simulate_alignment()
        sim_aln.info.source = "%s - alt - simalign %d" % (self._inpath, rep_num)

        try:
            sim_result = self._hyp(sim_aln).LR
        except ValueError:
            sim_result = None
        return sim_result

    def run(self, aln):
        result = generic_result(aln.info.source)
        try:
            obs = self._hyp(aln)
        except ValueError as err:
            result = NotCompleted("ERROR", str(self._hyp), err.args[0])
            return result
        result["observed"] = obs
        self._inpath = aln.info.source

        seed_alt_aln = obs.alt.simulate_alignment()
        seed_alt_aln.info.source = "%s - simalign - alt seed" % (self._inpath)
        try:
            obs_seed_alt = self._hyp(seed_alt_aln)
        except ValueError as err:
            result = NotCompleted("ERROR", str(self._hyp), err.args[0])
            return result
        result["alt_seed"] = obs_seed_alt

        seed_null_aln = obs.null.simulate_alignment()
        seed_null_aln.info.source = "%s - simalign - null seed" % (self._inpath)
        try:
            obs_seed_null = self._hyp(seed_null_aln)
        except ValueError as err:
            result = NotCompleted("ERROR", str(self._hyp), err.args[0])
            return result
        result["null_seed"] = obs_seed_null

        self._null_null = obs_seed_null.null
        map_fun = map if not self._parallel else parallel.imap

        null_sim_results = [
            r for r in map_fun(self._fit_null_sim, range(self._num_reps)) if r
        ]
        for i, null_sim_result in enumerate(null_sim_results):
            if not null_sim_result:
                continue
            result[f"null_sim_{i+1}-result"] = null_sim_result

        self._alt_null = obs_seed_alt.null

        alt_sim_results = [
            r for r in map_fun(self._fit_alt_sim, range(self._num_reps)) if r
        ]
        for i, alt_sim_result in enumerate(alt_sim_results):
            if not alt_sim_result:
                continue
            result[f"alt_sim_{i+1}-result"] = alt_sim_result

        return result


def expected_dists_hyp_app(num_reps=100, discrete_edges=None):
    """
    wrapper of cogent3.app.evo.bootstrap with hypothesis of GS as the null and GN as the alternate
    """

    GS = GS_sm(discrete_edges)
    GN = GN_sm(discrete_edges)

    hyp = evo.hypothesis(GS, GN, sequential=False)
    bstrap = expected_dist_hyp(hyp, num_reps)

    return bstrap


def _expected_dists_eop(alns):
    aln_1 = deserialise_object(alns["aln_1"])
    aln_2 = deserialise_object(alns["aln_2"])

    fg_edge = "Human"  # todo: hard-coded because I am in a rush :(
    eop = adjacent_EOP([aln_1, aln_2], fg=fg_edge)
    obs_eop_stats = eop.get_LRT_stats()

    null_lf = eop.null_lf
    aln1, aln2 = null_lf.locus_names

    null_aln_1 = null_lf.simulate_alignment(locus=aln1)
    null_aln_2 = null_lf.simulate_alignment(locus=aln2)

    null_eop = adjacent_EOP([null_aln_1, null_aln_2], fg=fg_edge)
    null_eop_stats = null_eop.get_LRT_stats()

    aln_lf_1 = eop.alt_lf[aln1]
    aln_lf_2 = eop.alt_lf[aln2]

    alt_aln_1 = aln_lf_1.simulate_alignment()
    alt_aln_2 = aln_lf_2.simulate_alignment()

    alt_eop = adjacent_EOP([alt_aln_1, alt_aln_2], fg=fg_edge)
    alt_eop_stats = alt_eop.get_LRT_stats()

    result = generic_result(source=alns.source)

    result.update(
        [
            ("obs_eop", obs_eop_stats),
            ("null_eop", null_eop_stats),
            ("alt_eop", alt_eop_stats),
        ]
    )

    return result


expected_dists_eop = user_function(
    _expected_dists_eop,
    input_types=SERIALISABLE_TYPE,
    output_types=SERIALISABLE_TYPE,
)
